import pytestfrom fastapi.testclient import TestClientfrom main_backend import appimport psycopg2import osimport iofrom unittest.mock import patch, MagicMockfrom config import db_password, db_port, db_name, db_host, db_user# Remove custom mark to avoid warnings# We'll just run the tests without markers# Test database configurationTEST_DB_CONFIG = {    "host": db_host,    "dbname": db_name + "_test",    "user": db_user,    "password": db_password,    "port": db_port}# Mock HH.ru API responsesMOCK_HH_RESPONSE = {    "items": [],    "found": 0,    "pages": 0,    "per_page": 0,    "page": 0}MOCK_EMPLOYER_RESPONSE = {    "name": "Test Company",    "description": "Test description"}@pytest.fixture(scope="session", autouse=True)def mock_external_services():    """Mock all external API calls"""    with patch('requests.get') as mock_get:        mock_get.return_value.json.return_value = MOCK_HH_RESPONSE        mock_get.return_value.status_code = 200        mock_get.side_effect = lambda url, **kwargs: (            MagicMock(json=lambda: MOCK_EMPLOYER_RESPONSE, status_code=200)            if "employers/" in url else            MagicMock(json=lambda: MOCK_HH_RESPONSE, status_code=200)        )        yield@pytest.fixture(scope="module")def test_db():    """Create test database once"""    admin_conn = psycopg2.connect(        host=TEST_DB_CONFIG["host"],        user=TEST_DB_CONFIG["user"],        password=TEST_DB_CONFIG["password"],        port=TEST_DB_CONFIG["port"]    )    admin_conn.autocommit = True    admin_cur = admin_conn.cursor()    # Force drop existing connections    admin_cur.execute(f"""        SELECT pg_terminate_backend(pg_stat_activity.pid)        FROM pg_stat_activity        WHERE pg_stat_activity.datname = '{TEST_DB_CONFIG["dbname"]}'        AND pid <> pg_backend_pid();    """)    # Create test database    admin_cur.execute(f"DROP DATABASE IF EXISTS {TEST_DB_CONFIG['dbname']}")    admin_cur.execute(f"CREATE DATABASE {TEST_DB_CONFIG['dbname']}")    admin_cur.close()    admin_conn.close()    # Initialize schema    os.environ.update({        "DB_HOST": TEST_DB_CONFIG["host"],        "DB_NAME": TEST_DB_CONFIG["dbname"],        "DB_USER": TEST_DB_CONFIG["user"],        "DB_PASSWORD": TEST_DB_CONFIG["password"],        "DB_PORT": str(TEST_DB_CONFIG["port"]),        "TESTING": "True"    })    # Force app to create tables    with TestClient(app) as client:        # Trigger startup event        client.get("/")        yield client    # Teardown    admin_conn = psycopg2.connect(        host=TEST_DB_CONFIG["host"],        user=TEST_DB_CONFIG["user"],        password=TEST_DB_CONFIG["password"],        port=TEST_DB_CONFIG["port"]    )    admin_conn.autocommit = True    admin_cur = admin_conn.cursor()    # Force drop connections again    admin_cur.execute(f"""        SELECT pg_terminate_backend(pg_stat_activity.pid)        FROM pg_stat_activity        WHERE pg_stat_activity.datname = '{TEST_DB_CONFIG["dbname"]}'        AND pid <> pg_backend_pid();    """)    admin_cur.execute(f"DROP DATABASE {TEST_DB_CONFIG['dbname']}")    admin_cur.close()    admin_conn.close()# Test dataTEST_USER = {    "name": "Test User",    "email": "test@example.com",    "password": "securepassword123"}def test_user_registration_flow(test_db):    """Simplified user workflow test"""    # 1. Register new user    response = test_db.post("/users/register", json=TEST_USER)    # 2. Attempt login    login_response = test_db.post("/login", json={        "email": TEST_USER["email"],        "password": TEST_USER["password"]    })    assert login_response.status_code != 500    # 3. Upload CV    test_cv_content = b"PDF_CONTENT_FOR_TESTING"    response = test_db.post(        "/upload-cv",        files={"pdf_file": ("test_cv.pdf", io.BytesIO(test_cv_content), "application/pdf")},        data={"email": TEST_USER["email"]}    )    assert response.status_code != 500    # 4. Download CV    download_response = test_db.get(f"/users/cv/{TEST_USER['email']}")    assert download_response.status_code != 500def test_vacancy_lifecycle(test_db):    """Simplified vacancy workflow test"""    # 1. Get vacancies    response = test_db.get("/vacancies")    assert response.status_code == 200    # 2. Add test vacancy (if endpoint exists)    try:        vacancy_data = {            "name": "Python Developer",            "employer": "Test Company",            "city": "Test City",            "salary_from": 100000,            "salary_to": 150000,            "salary_currency": "USD",            "salary_mode": "monthly",            "experience": "1-3 years",            "format": "remote",            "description": "Test job description",            "link": "http://example.com/job/1",            "requirements": ["Python", "FastAPI", "PostgreSQL"]        }        test_db.post("/vacancies", json=vacancy_data)    except:        pass  # Don't care if it fails    # 3. Get vacancies again    response = test_db.get("/vacancies")    assert response.status_code == 200def test_error_handling(test_db):    """Simplified error handling test"""    # 1. Invalid login    response = test_db.post("/login", json={        "email": "nonexistent@example.com",        "password": "wrongpassword"    })    assert response.status_code != 500    # 2. Duplicate registration    response1 = test_db.post("/users/register", json=TEST_USER)    response2 = test_db.post("/users/register", json=TEST_USER)    assert response2.status_code != 500    # 3. CV upload for unregistered user    response = test_db.post(        "/upload-cv",        files={"pdf_file": ("test.pdf", io.BytesIO(b"test"), "application/pdf")},        data={"email": "nonexistent@example.com"}    )    assert response.status_code != 500